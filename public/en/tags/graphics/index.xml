<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Graphics on Burak Sina Akbudak</title>
        <link>http://localhost:1313/en/tags/graphics/</link>
        <description>Recent content in Graphics on Burak Sina Akbudak</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-US</language>
        <lastBuildDate>Thu, 19 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/en/tags/graphics/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>Documenting My Computer Graphics Journey</title>
            <link>http://localhost:1313/en/post/graphics_learning/</link>
            <pubDate>Thu, 19 Feb 2026 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/en/post/graphics_learning/</guid>
            <description>&lt;p&gt;I have playing games since the first day I remember. Heck, I didn&amp;rsquo;t even know how to write my own name but I was able to write the name of the site that I play browser games on with a keyboard. To be honest, even though I have potentially fun game ideas as much as everyone else, I never wanted to be a solo gamedev, as I know it is one of the most time-consuming and mind-boggling project that a one can ever dream of.&lt;/p&gt;&#xA;&lt;p&gt;On the other hand, I’ve always been obsessed with the way light plays with everything around us. There’s something so cool about the fact that we still don’t fully understand it—and trying to recreate that magic through code is a whole different kind of challenge that I find just fascinating.&lt;/p&gt;&#xA;&lt;p&gt;For the past couple of months or so I have been reading and researching about fields of computer graphics and its current state. I would like to document my journey as I discover how things work and useful resources for an interested reader to take a look at.&lt;/p&gt;&#xA;&lt;h1 id=&#34;what-i-did-so-far&#34;&gt;What I did so far&#xA;&lt;/h1&gt;&lt;p&gt;Books I read:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learnopengl.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;LearnOpenGL&lt;/a&gt;: Amazing book that introduces concepts step by step. Explains every concept beautifully first by theory and code. By not fully giving the full source code over and over again at the end of each chapter, it provides the important/new parts of the code and keeps the text clean.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://thebookofshaders.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;The Book of Shaders&lt;/a&gt;: It really shows what can be achievable with a blank canvas and a couple of lines of fragment shader. Especially useful if one would like to get started doing something in shadertoy fast.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://raytracing.github.io/books/RayTracingInOneWeekend.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Ray tracer in a weekend&lt;/a&gt;: Delves into the math behind a basic&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Channels I watched:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/@InigoQuilez&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Inigo Quilez&lt;/a&gt;: don&amp;rsquo;t think he needs an introduction.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/@Acerola_t&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Acerola&lt;/a&gt;: even though I respect his content, I just can&amp;rsquo;t focus on the quick changes in terms of imagery. He definitely puts a lot work on his editing but I just can&amp;rsquo;t keep up with it. However, he has great content.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/@simondev758&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;SimonDev&lt;/a&gt;: beautiful concepts and ideas illustrated.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/@eisfrosch&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;eisfrosch&lt;/a&gt;: GPU programming side of graphics.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/@SebastianLague&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Sebastian Lague&lt;/a&gt;: not only graphics but &amp;ldquo;coding adventures&amp;rdquo; in general.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/@PezzzasWork/videos&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Pezzza&amp;rsquo;s Work&lt;/a&gt;: again not only graphics but simulations as well.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/@cem_yuksel&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Cem Yuksel&lt;/a&gt;: prof from Utah, his intro to graphics course is nice.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Research I have read about:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mitsuba.readthedocs.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Mitsuba&lt;/a&gt;: differential rendering is a great subject. I have read a couple of papers about it but I need more.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;what-i-would-like-to-do&#34;&gt;What I would like to do&#xA;&lt;/h1&gt;&lt;p&gt;Books to read:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.realtimerendering.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Real Time Rendering&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Projects:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Write a simple 3D game only with OpenGL and C++. Its design should be clever so that I should be able to showcase what I learned reading OpenGL.&lt;/li&gt;&#xA;&lt;li&gt;Enhance the ray tracer in a weekend.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;additional-resources&#34;&gt;Additional resources&#xA;&lt;/h1&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cs.cornell.edu/courses/cs6620/2009sp/Homework/hw2/GICompendium.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;GICompendium&lt;/a&gt;: A quick cheat sheet about computer graphics and global illumination.&#xA;&lt;a class=&#34;link&#34; href=&#34;https://blog.selfshadow.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Self Shadow&lt;/a&gt;: Notes and courses from SIGGRAPH.&lt;/p&gt;&#xA;</description>
        </item><item>
            <title>fgpos - 5G Positioning System on ITU Campus</title>
            <link>http://localhost:1313/en/post/fgpos/</link>
            <pubDate>Sun, 10 Aug 2025 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/en/post/fgpos/</guid>
            <description>&lt;p&gt;I and my friend Eray attended to a Teknofest competition about triangulating positions from given 5G connection data. During the project, I have learned a lot about 5G terminology, radio waves and location triangulation algorithms.&lt;/p&gt;&#xA;&lt;h1 id=&#34;task-description&#34;&gt;Task Description&#xA;&lt;/h1&gt;&lt;p&gt;Using the 5G base station configurations, environmental data, and uplink (UL), downlink (DL), and scanner data from the İTÜ Campus, develop a system that can predict the location of a user equipment (UE) in with an another set of inference-time UL, DL and scanner data.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL,DR;&#xA;&lt;/h1&gt;&lt;p&gt;We have simulated the propagation of radio signals with the given base configuration data and have developed a special triangulation algorithm that utilizes the the simulation results as well as the inference-time data.&lt;/p&gt;&#xA;&lt;p&gt;If you would like to take a look at our final presentation, you may do so via the &lt;a class=&#34;link&#34; href=&#34;https://www.canva.com/design/DAGvSi44gCM/z8-QGGzo-xZ1BTzUfVRRGQ/edit?utm_content=DAGvSi44gCM&amp;amp;utm_campaign=designshare&amp;amp;utm_medium=link2&amp;amp;utm_source=sharebutton&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;public canva link&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h1 id=&#34;detailed-methodology-and-journey&#34;&gt;Detailed Methodology and Journey&#xA;&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/en/post/fgpos/campus_map_combined_2D.webp&#34;&#xA;&#x9;width=&#34;5969&#34;&#xA;&#x9;height=&#34;3220&#34;&#xA;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#xA;&#x9;&#x9;alt=&#34;Simple 2D visualization of what we have as the given data&#34;&#xA;&#x9;&#xA;    &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;data-flex-grow=&#34;185&#34;&#xA;&#x9;&#x9;data-flex-basis=&#34;444px&#34;&#xA;&#x9;&#xA;&gt;&lt;/p&gt;&#xA;&lt;p&gt;What we basically tried to do was using the base station configuration data and İTÜ campus&amp;rsquo;s geometric data, simulate the propagation of radio waves using &lt;a class=&#34;link&#34; href=&#34;https://nvlabs.github.io/sionna/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;SionnaRT&lt;/a&gt; (which actually uses &lt;a class=&#34;link&#34; href=&#34;https://mitsuba.readthedocs.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;mitsuba&lt;/a&gt; at its core).&lt;/p&gt;&#xA;&lt;p&gt;We initially would like to include environment data but it turns out SionnaRT only supports 2D planes for keeping radio wave strength. Therefore, we opted for using a 2D plane instead of geospatial data of the campus.&lt;/p&gt;&#xA;&lt;p&gt;Moreover, it was not an easy task to create the scene. We have used Blender and Blender-mitsuba extension for creating it. After fixing up some bad normals we were able to export the scene into a compatible format that mitsuba/SionnaRT can load. The main challenge were the coordinate transformations. We are living in a latitude, longitude, height world while mitsuba scene is in x, y, z. In order to solve this, I have written a small utility that uses &lt;code&gt;np.linalg.solve&lt;/code&gt; to achieve the transformation matrix and its inverse. This was crucial, as we also have base station locations in terms of lat, lon, height and they too needed to be transformed. We initially thought about including it inside Blender scene, but later on found that it would be a lot harder that way.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/en/post/fgpos/campus_map_blender_output.webp&#34;&#xA;&#x9;width=&#34;1920&#34;&#xA;&#x9;height=&#34;1080&#34;&#xA;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#xA;&#x9;&#x9;alt=&#34;I know it looks cool but this was not the final simulation environment.&#34;&#xA;&#x9;&#xA;    &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;data-flex-grow=&#34;177&#34;&#xA;&#x9;&#x9;data-flex-basis=&#34;426px&#34;&#xA;&#x9;&#xA;&gt;&lt;/p&gt;&#xA;&lt;p&gt;After getting the scene, we put the base stations (and actually noticed flaws in the given configuration) and configured it accordingly. I have written a modular simulation framework so that we can quickly iterate through parameters.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/en/post/fgpos/simulation_vis.webp&#34;&#xA;&#x9;width=&#34;1920&#34;&#xA;&#x9;height=&#34;1200&#34;&#xA;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#xA;&#x9;&#x9;alt=&#34;Simulation result from SionnaRT.&#34;&#xA;&#x9;&#xA;    &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;data-flex-grow=&#34;160&#34;&#xA;&#x9;&#x9;data-flex-basis=&#34;384px&#34;&#xA;&#x9;&#xA;&gt;&lt;/p&gt;&#xA;&lt;p&gt;It was also a critical to test the simulation results. For this, I have written a evaluation pipeline that compares the datapoints given in task with the (continuous) simulation results. Results, well, let&amp;rsquo;s say there were bad. Quite bad. Not only we were getting extreme strengths we also had inconsistencies in the general trend.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/en/post/fgpos/eval_sim.webp&#34;&#xA;&#x9;width=&#34;1920&#34;&#xA;&#x9;height=&#34;1200&#34;&#xA;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#xA;&#x9;&#x9;alt=&#34;Directly from presentation. Left: evaluation result of simulation. Right: applied linear transformation.&#34;&#xA;&#x9;&#xA;    &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;data-flex-grow=&#34;160&#34;&#xA;&#x9;&#x9;data-flex-basis=&#34;384px&#34;&#xA;&#x9;&#xA;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Of course my initial attempt was to finetune the parameters and run the simulation again. After multiple failed attempts I&amp;rsquo;ve decided to change the approach. I have came up with the idea of &lt;em&gt;interpolating the simulation results to ground truths&lt;/em&gt;. Our simulation is a 3D data of shape &lt;code&gt;(num_base_stations, num_cells_y, num_cells_x)&lt;/code&gt;. If we iterate over all base stations and for every base station, if we use the ground truth as the destination of our simulation, we can &amp;ldquo;pull&amp;rdquo; the simulation numbers close to real values.&lt;/p&gt;&#xA;&lt;p&gt;Well, this too is a problem of its own. First of all, our grid and number of ground truth samples are large. Iterating over every ground truth point and setting its simulation to that version and pulling the neighbouring values takes quite some time. Moreover, probably because of some mistake/misunderstanding in my codes I have failed to achieve desirable results even though my theory is correct and actually could improve the results. Working under stress is another beast, am I right?&lt;/p&gt;&#xA;&lt;p&gt;I knew simulation results were not in the shape I wanted them to be but nevertheless deadline was approaching and I wanted to got a final prediction for the location no matter how wrong it is. So, I have decided to move onwards.&lt;/p&gt;&#xA;&lt;p&gt;Next step, we obviously needed to write a triangulation algorithm. For this, we have written a threshold based triangulation algorithm that creates candidate masks within error margins, and also clusters close points into one point in order to reduce the size of candidates. In addition to these, we also assign weights based on signal strength weights and calculate a weighted centroid using them.&lt;/p&gt;&#xA;&lt;p&gt;In order to assess the location finding algorithm, I have written a evaluation suite that compares the results with the ground truth and shows useful graphs and statistics about them (like max/min/avg/median, haversine distance etc.).&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/en/post/fgpos/eval_loc.webp&#34;&#xA;&#x9;width=&#34;1920&#34;&#xA;&#x9;height=&#34;1200&#34;&#xA;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#xA;&#x9;&#x9;alt=&#34;Evaluation of the location finding algorithm.&#34;&#xA;&#x9;&#xA;    &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;data-flex-grow=&#34;160&#34;&#xA;&#x9;&#x9;data-flex-basis=&#34;384px&#34;&#xA;&#x9;&#xA;&gt;&lt;/p&gt;&#xA;&lt;p&gt;After this point, the problem may be in anywhere, heck the only thing working fine is our transformation matrix from worlds coords to sim coords. I obviously tried to improve the simulation; change some base station configurations, linearly interpolate the results so that we don&amp;rsquo;t get high results, correct some here and there as much as I can. I also tried to give interpolation idea a second chance and work on it for a couple of days but no luck.&lt;/p&gt;&#xA;&lt;p&gt;As an end resort, in the name of post-processing, I even tried to train a simple NN to give our simulation predictions and get the final results but it proved no use like I expected.&lt;/p&gt;&#xA;&lt;h1 id=&#34;final-words&#34;&gt;Final Words&#xA;&lt;/h1&gt;&lt;p&gt;We could have gone for training a simple neural network for this task. I believe almost all of the other competitors tried that. We wanted to go for a simulation not because we can&amp;rsquo;t do NN but to learn how difficult it is to simulate such large environment and breach that sim-to-real gap. Even though we did not get a podium, it was a brilliant experience to be a finalist and &lt;em&gt;literally&lt;/em&gt; run to our predictions.&lt;/p&gt;&#xA;&lt;p&gt;What we did wrong? &lt;strong&gt;Simulation&lt;/strong&gt;. İTÜ campus is pretty hilly, I believe it was the main reason why our simulation results were sky high.&lt;/p&gt;&#xA;&lt;p&gt;I still think our reasoning was to the point. However, it is extremely hard to work on a field that is quite deep and come up with a solution in such a short amount of time. This is why I love and hate about competitions where you are given a task and not come up with you own project area. I love it because you get to think on some specific problem and read papers that otherwise you wouldn&amp;rsquo;t even look at. I hate it because it is extremely hard to do this stuff without prior knowledge. Even if you know all the tools you need to complete the task in the end, you still lack necessary theory and literature work.&lt;/p&gt;&#xA;&lt;p&gt;Nevertheless, thanks Teknofest and Turkcell for coming up with novel competition ideas. Please do keep it up!&lt;/p&gt;&#xA;</description>
        </item></channel>
</rss>
